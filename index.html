<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Space Invaders - Mobile</title>
    <script>
        // Redirect logic based on device type
        (function() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (!isMobile) {
                window.location.href = "https://spaceinvaders.deewhy.ovh/";
            }
        })();
    </script>
    <style>
        /* --- Ensure full viewport coverage and centering --- */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%; /* Full viewport height */
            width: 100%;  /* Full viewport width */
            overflow: hidden; /* Prevent scrolling */
        }
        body {
            /* Use flexbox on body to center #gameContainer */
            display: flex;
            justify-content: center; /* Center horizontally */
            align-items: center;     /* Center vertically */
            background: radial-gradient(ellipse at center, #1a0033 0%, #000 70%);
            font-family: 'Courier New', monospace;
            touch-action: none;
        }
        /* --- End of viewport coverage and centering --- */
        #gameContainer {
            /* Make #gameContainer fill available space, but respect aspect ratio */
            width: 100%;
            height: 100%;
            /* Maintain the game's original aspect ratio (400x600 = 2:3) */
            aspect-ratio: 400 / 600;
            /* Max constraints to prevent it from becoming larger than intended */
            max-width: min(100vw, (100vh * 400 / 600)); /* Ensures it fits within width */
            max-height: min(100vh, (100vw * 600 / 400)); /* Ensures it fits within height */
            border: 3px solid #00ffff;
            border-radius: 15px;
            box-shadow:
                0 0 30px #00ffff,
                inset 0 0 30px rgba(0, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            /* Flexbox to center canvas and absolutely positioned children */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; /* Needed for absolutely positioned children */
            box-sizing: border-box; /* Include padding/border in dimensions if any */
        }
        canvas {
            display: block;
            /* Canvas will scale to fit its parent container */
            width: 100%;
            height: 100%;
            object-fit: contain; /* Scale canvas to fit container while maintaining aspect ratio */
            background: linear-gradient(180deg, #000428 0%, #004e92 50%, #000428 100%);
            border-radius: 12px;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        /* --- UI Elements positioned absolutely within #gameContainer --- */
        #gameInfo {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #00ffff;
            font-size: 16px;
            font-weight: bold;
            z-index: 10;
            text-shadow: 0 0 10px #00ffff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            /* Prevent text selection */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .powerup-line {
            color: #ffcc00;
            text-shadow: 0 0 10px #ffcc00;
        }
        #moveControls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        #fireControl {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 10;
        }
        /* --- End of UI Elements --- */
        /* --- Controls Styling (Unchanged) --- */
        .control-btn {
            width: 70px;
            height: 70px;
            background: linear-gradient(145deg, rgba(0, 255, 255, 0.4), rgba(0, 150, 255, 0.2));
            border: 3px solid #00ffff;
            border-radius: 50%;
            color: #00ffff;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            cursor: pointer;
            touch-action: manipulation;
            box-shadow:
                0 0 20px rgba(0, 255, 255, 0.5),
                inset 0 0 20px rgba(255, 255, 255, 0.1);
            transition: all 0.2s ease;
        }
        .control-btn:active {
            background: linear-gradient(145deg, rgba(0, 255, 255, 0.8), rgba(0, 150, 255, 0.6));
            transform: scale(0.95);
            box-shadow:
                0 0 30px rgba(0, 255, 255, 0.8),
                inset 0 0 20px rgba(255, 255, 255, 0.2);
        }
        #fireBtn {
            width: 70px;
            height: 70px;
            background: linear-gradient(145deg, rgba(255, 100, 100, 0.4), rgba(255, 50, 50, 0.2));
            border-color: #ff6666;
            color: #ff6666;
            font-size: 28px;
            box-shadow:
                0 0 25px rgba(255, 100, 100, 0.6),
                inset 0 0 25px rgba(255, 255, 255, 0.1);
        }
        #fireBtn:active {
            background: linear-gradient(145deg, rgba(255, 100, 100, 0.8), rgba(255, 50, 50, 0.6));
            transform: scale(0.95);
            box-shadow:
                0 0 35px rgba(255, 100, 100, 0.9),
                inset 0 0 25px rgba(255, 255, 255, 0.2);
        }
        /* --- End of Controls Styling --- */
        /* --- Screens (Unchanged, but rely on body flex for centering) --- */
        #gameOverScreen, #startScreen, #scoreboardScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ff00;
            text-align: center;
            z-index: 20;
            padding: 0 10px;
            box-sizing: border-box;
        }
        #startScreen {
            display: flex;
        }
        #startScreen h1 {
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #00ffff;
            color: #00ffff;
            animation: glow 2s ease-in-out infinite alternate;
            letter-spacing: 3px;
        }
        @keyframes glow {
            from {
                text-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff;
                color: #00ffff;
            }
            to {
                text-shadow: 0 0 30px #00ffff, 0 0 40px #00ffff, 0 0 50px #ff00ff;
                color: #ff88ff;
            }
        }
        #startScreen p {
            font-size: 16px;
            margin-bottom: 30px;
            opacity: 0.8;
        }
        #instructions {
            font-size: 14px;
            margin-bottom: 30px;
            line-height: 1.5;
            opacity: 0.7;
        }
        #restartBtn, #playBtn, #scoreboardBtn, #closeScoreboardBtn, #backToStartBtn {
            padding: 15px 25px;
            background: linear-gradient(145deg, rgba(0, 255, 255, 0.4), rgba(0, 150, 255, 0.2));
            border: 3px solid #00ffff;
            color: #00ffff;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
            border-radius: 10px;
            text-shadow: 0 0 10px #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        }
        #restartBtn:hover, #playBtn:hover, #scoreboardBtn:hover, #closeScoreboardBtn:hover, #backToStartBtn:hover {
            background: linear-gradient(145deg, rgba(0, 255, 255, 0.6), rgba(0, 150, 255, 0.4));
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.7);
        }
        #playBtn {
            font-size: 22px;
            padding: 20px 40px;
            animation: pulse 1.5s ease-in-out infinite alternate;
        }
        @keyframes pulse {
            from {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            }
            to {
                transform: scale(1.05);
                box-shadow: 0 0 35px rgba(0, 255, 255, 0.8);
            }
        }
        #scoreboardContainer {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 10px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            width: 80%;
        }
        #scoreboardTable {
            width: 100%;
            border-collapse: collapse;
        }
        #scoreboardTable th, #scoreboardTable td {
            padding: 10px 8px;
            text-align: center;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffcc;
            font-size: 14px;
        }
        #scoreboardTable th {
            background: rgba(0, 255, 255, 0.1);
            color: #00ffff;
            font-weight: bold;
        }
        #scoreboardTable tr:nth-child(even) {
            background: rgba(0, 0, 0, 0.5);
        }
        #scoreboardTable tr:hover {
            background: rgba(0, 255, 255, 0.15);
        }
        #nicknameInput {
            width: 150px;
            padding: 10px;
            margin: 10px 0;
            border: 2px solid #00ffff;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ffff;
            font-family: 'Courier New', monospace;
            text-align: center;
        }
        #submitNickname {
            padding: 10px 15px;
            background: linear-gradient(145deg, rgba(0, 255, 255, 0.4), rgba(0, 150, 255, 0.2));
            border: 2px solid #00ffff;
            color: #00ffff;
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
            margin: 5px;
            transition: all 0.3s ease;
        }
        #submitNickname:hover {
            background: linear-gradient(145deg, rgba(0, 255, 255, 0.6), rgba(0, 150, 255, 0.4));
            transform: scale(1.05);
        }
        #submitNickname:disabled {
            background: rgba(0, 255, 255, 0.2);
            cursor: not-allowed;
            opacity: 0.6;
        }
        .score-submitted-message {
            color: #00ff00;
            margin: 10px 0;
            font-size: 18px;
            text-shadow: 0 0 10px #00ff00;
        }
        .loading-message {
            color: #ffff00;
            margin: 20px 0;
        }
        .buttons-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
        }
        .button-row {
            display: flex;
            gap: 15px;
            width: 100%;
            justify-content: center;
        }
        .button-row > button {
            flex: 1;
            max-width: 200px;
            text-align: center;
        }
        /* --- End of Screens --- */
        
        /* --- GAME OVER SCREEN FIXES --- */
        #gameOverScreen > div {
            max-width: 320px;
            width: 90%;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
            box-sizing: border-box;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #gameOverScreen h1 {
            margin: 0;
            font-size: 2.5rem;
        }
        
        #gameOverScreen p {
            margin: 0;
            font-size: 1.2rem;
        }
        
        #nicknameForm {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        
        #nicknameForm input {
            text-align: center;
            width: 100%;
            max-width: 200px;
        }
        
        #nicknameForm button {
            width: 100%;
            max-width: 200px;
        }
        
        #paypal-section {
            margin: 20px 0 0 0;
            padding: 20px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            border-radius: 12px;
            text-align: center;
            width: 100%;
            box-sizing: border-box;
        }
        
        #paypal-section h3 {
            color: #00ffff;
            margin: 0 0 12px 0;
            font-size: 1.3rem;
        }
        
        #paypal-section p {
            color: #ffffff;
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        
        #paypal-section .price {
            color: #ffcc00;
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: bold;
        }
        
        #paypalForm {
            margin: 0;
        }
        
        #paypalForm table {
            margin: 0 auto 15px auto;
        }
        
        #paypalForm select {
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #00ffff;
            background: rgba(0,0,0,0.5);
            color: white;
            width: 100%;
            max-width: 220px;
            margin: 0 auto;
            display: block;
        }
        
        #paypalForm input[type="image"] {
            margin: 0;
        }
        
        #restartBtn, #backToStartBtn {
            width: 100%;
            max-width: 220px;
            margin-top: 10px;
            margin-left: auto;
            margin-right: auto;
        }
        /* --- END GAME OVER SCREEN FIXES --- */
    </style>
</head>
<body>
    <noscript>
        <meta http-equiv="refresh" content="0;url=https://spaceinvaders.deewhy.ovh/">
    </noscript>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        <div id="gameInfo">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Level: <span id="level">1</span></div>
            <div class="powerup-line">Power-ups: <span id="powerupStatus">None</span></div>
        </div>
        <div id="moveControls">
            <div class="control-btn" id="leftBtn" aria-label="Move Left">←</div>
            <div class="control-btn" id="rightBtn" aria-label="Move Right">→</div>
        </div>
        <div id="fireControl">
            <div class="control-btn" id="fireBtn" aria-label="Fire Weapon">⚡</div>
        </div>
        <!-- START SCREEN -->
        <div id="startScreen">
            <div>
                <h1>SPACE INVADERS</h1>
                <p>Defend Earth from the alien invasion!</p>
                <div id="instructions">
                    <div>🚀 Use arrow buttons to move</div>
                    <div>⚡ Tap lightning bolt to fire</div>
                    <div>💥 Destroy all aliens to advance</div>
                    <div>❤️ You have 3 lives - don't get hit!</div>
                    <div>🌟 Collect power-ups for special abilities</div>
                    <div>👾 Boss appears every 5 levels</div>
                </div>
                <div class="buttons-container">
                    <button id="playBtn">PLAY GAME</button>
                    <button id="scoreboardBtn">SCOREBOARD</button>
                </div>
            </div>
        </div>
        <!-- GAME OVER SCREEN -->
        <div id="gameOverScreen">
            <div>
                <h1>GAME OVER</h1>
                <p>Final Score: <span id="finalScore">0</span></p>
                <div id="nicknameForm">
                    <input type="text" id="nicknameInput" placeholder="Enter nickname (8 chars)" maxlength="8" />
                    <button id="submitNickname">Submit</button>
                </div>
                <div id="scoreSubmittedMessage" class="score-submitted-message" style="display: none;">
                    Score submitted successfully!
                </div>
                <!-- PAYPAL SECTION -->
                <div id="paypal-section">
                    <h3>CONTINUE YOUR MISSION!</h3>
                    <p>
                        Purchase <strong>3 Extra Lives</strong> to resume from <strong>Level <span id="continueLevel">1</span></strong>.
                    </p>
                    <p class="price">
                        Price: $1.99 USD
                    </p>
                    <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank" rel="noopener noreferrer" id="paypalForm">
                      <input type="hidden" name="cmd" value="_s-xclick" />
                      <input type="hidden" name="hosted_button_id" value="HVBB9YEJB8KMY" />
                      <input type="hidden" name="custom" id="paypalSessionToken" value="" />
                      <table>
                        <tr>
                          <td>
                            <input type="hidden" name="on0" value="SPACE INVADERS"/>
                            <span style="font-weight: bold; color: #00ffff;">SPACE INVADERS</span>
                          </td>
                        </tr>
                        <tr>
                          <td>
                            <select name="os0">
                              <option value="3 Additional Life Bundle">
                                3 Additional Life Bundle
                              </option>
                            </select>
                          </td>
                        </tr>
                      </table>
                      <input type="hidden" name="currency_code" value="USD" />
                      <input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_buynow_SM.gif" border="0" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Buy Now" />
                    </form>
                </div>
                <button id="restartBtn">RESTART GAME</button>
                <button id="backToStartBtn">BACK TO START</button>
            </div>
        </div>
        <!-- SCOREBOARD SCREEN -->
        <div id="scoreboardScreen">
            <h1>SCOREBOARD</h1>
            <div id="loadingMessage" class="loading-message">Loading scores...</div>
            <div id="scoreboardContainer">
                <table id="scoreboardTable">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Name</th>
                            <th>Score</th>
                            <th>Level</th>
                        </tr>
                    </thead>
                    <tbody id="scoreboardBody">
                        <!-- Scores will be populated here -->
                    </tbody>
                </table>
            </div>
            <button id="closeScoreboardBtn">CLOSE</button>
        </div>
    </div>
    <!-- The JavaScript remains unchanged -->
    <script>
        // ... (Your existing JavaScript code remains the same) ...
         class SpaceInvadersGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 400;
                this.canvas.height = 600;
                this.canvas.addEventListener('touchstart', e => e.preventDefault());
                this.canvas.addEventListener('touchmove', e => e.preventDefault());
                this.canvas.addEventListener('touchend', e => e.preventDefault());
                this.gameStarted = false;
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.gameRunning = false;
                this.gameOver = false;
                this.paypalSessionToken = null;
                this.player = null;
                this.enemies = [];
                this.playerBullets = [];
                this.enemyBullets = [];
                this.stars = [];
                this.powerups = [];
                this.particles = [];
                this.boss = null;
                this.keys = { left: false, right: false, fire: false };
                this.lastEnemyMoveTime = 0;
                this.lastEnemyShootTime = 0;
                this.lastPowerupSpawnTime = 0;
                this.enemyMoveDelay = 1000;
                this.enemyShootDelay = 2000;
                this.powerupSpawnDelay = 15000;
                this.vibrationSupported = !!navigator.vibrate;
                this.init();
            }
            init() {
                this.setupControls();
                this.createStarField();
                 // Remove the resize handler as object-fit handles scaling
                 // window.addEventListener('resize', () => this.handleResize());
                 // this.handleResize();
                this.gameLoop();
            }
             // Remove or comment out the handleResize function as it's no longer needed
            // handleResize() {
            //     const container = document.getElementById('gameContainer');
            //     const containerRect = container.getBoundingClientRect();
            //     const scale = Math.min(containerRect.width / 400, containerRect.height / 600);
            //     this.canvas.style.width = `${400 * scale}px`;
            //     this.canvas.style.height = `${600 * scale}px`;
            // }
            setupControls() {
                const leftBtn = document.getElementById('leftBtn');
                const rightBtn = document.getElementById('rightBtn');
                const fireBtn = document.getElementById('fireBtn');
                const restartBtn = document.getElementById('restartBtn');
                const playBtn = document.getElementById('playBtn');
                const scoreboardBtn = document.getElementById('scoreboardBtn');
                const closeScoreboardBtn = document.getElementById('closeScoreboardBtn');
                const backToStartBtn = document.getElementById('backToStartBtn');
                document.addEventListener('contextmenu', (e) => e.preventDefault());
                leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); this.keys.left = true; });
                leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); this.keys.left = false; });
                leftBtn.addEventListener('mousedown', () => this.keys.left = true);
                leftBtn.addEventListener('mouseup', () => this.keys.left = false);
                rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); this.keys.right = true; });
                rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); this.keys.right = false; });
                rightBtn.addEventListener('mousedown', () => this.keys.right = true);
                rightBtn.addEventListener('mouseup', () => this.keys.right = false);
                fireBtn.addEventListener('touchstart', (e) => { e.preventDefault(); this.keys.fire = true; });
                fireBtn.addEventListener('touchend', (e) => { e.preventDefault(); this.keys.fire = false; });
                fireBtn.addEventListener('mousedown', () => this.keys.fire = true);
                fireBtn.addEventListener('mouseup', () => this.keys.fire = false);
                restartBtn.addEventListener('click', () => this.restartGame());
                playBtn.addEventListener('click', () => this.startGame());
                scoreboardBtn.addEventListener('click', () => this.showScoreboard());
                closeScoreboardBtn.addEventListener('click', () => this.hideScoreboard());
                backToStartBtn.addEventListener('click', () => this.showStartScreen());
                document.addEventListener('keydown', (e) => {
                    switch(e.code) {
                        case 'ArrowLeft': this.keys.left = true; break;
                        case 'ArrowRight': this.keys.right = true; break;
                        case 'Space': this.keys.fire = true; break;
                    }
                });
                document.addEventListener('keyup', (e) => {
                    switch(e.code) {
                        case 'ArrowLeft': this.keys.left = false; break;
                        case 'ArrowRight': this.keys.right = false; break;
                        case 'Space': this.keys.fire = false; break;
                    }
                });
                const submitNickname = document.getElementById('submitNickname');
                submitNickname.addEventListener('click', () => {
                    const nicknameInput = document.getElementById('nicknameInput');
                    const nickname = nicknameInput.value.trim();
                    if (nickname.length > 0 && nickname.length <= 8) {
                        submitNickname.disabled = true;
                        this.saveHighScore(nickname);
                        nicknameInput.value = '';
                    } else {
                        alert("Please enter a nickname (1-8 characters)");
                    }
                });
            }
            createStarField() {
                this.stars = [];
                for (let i = 0; i < 100; i++) {
                    this.stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        brightness: Math.random(),
                        size: Math.random() * 2 + 0.5,
                        twinkleSpeed: Math.random() * 0.02 + 0.005,
                        twinklePhase: Math.random() * Math.PI * 2
                    });
                }
                for (let i = 0; i < 20; i++) {
                    this.stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        brightness: 0.8 + Math.random() * 0.2,
                        size: Math.random() * 3 + 2,
                        twinkleSpeed: Math.random() * 0.01 + 0.003,
                        twinklePhase: Math.random() * Math.PI * 2,
                        color: ['#ffffff', '#ffdddd', '#ddddff', '#ffffdd'][Math.floor(Math.random() * 4)]
                    });
                }
            }
            startGame() {
                this.gameStarted = true;
                this.resetGame();
                document.getElementById('startScreen').style.display = 'none';
            }
            resetGame() {
                this.gameRunning = true;
                this.gameOver = false;
                if (this.paypalSessionToken) {
                    fetch(`/api/check-continue/${this.paypalSessionToken}`)
                        .then(response => {
                            if (response.ok) return response.json();
                            else throw new Error('Session not found');
                        })
                        .then(data => {
                            if (data.hasPurchasedContinue) {
                                this.score = 0;
                                this.lives = 3;
                                this.level = data.level;
                                console.log(`Player continuing from level ${this.level} with ${this.lives} lives.`);
                            } else {
                                this.score = 0;
                                this.lives = 3;
                                this.level = 1;
                            }
                        })
                        .catch(error => {
                            console.error('Error checking continue status:', error);
                            this.score = 0;
                            this.lives = 3;
                            this.level = 1;
                        })
                        .finally(() => {
                            this.player = new Player(this.canvas.width / 2 -20, this.canvas.height - 150);
                            this.createEnemies();
                            this.playerBullets = [];
                            this.enemyBullets = [];
                            this.powerups = [];
                            this.particles = [];
                            this.boss = null;
                            this.updateUI();
                            document.getElementById('gameOverScreen').style.display = 'none';
                            document.getElementById('scoreboardScreen').style.display = 'none';
                        });
                } else {
                    this.score = 0;
                    this.lives = 3;
                    this.level = 1;
                    this.player = new Player(this.canvas.width / 2 -20, this.canvas.height - 150);
                    this.createEnemies();
                    this.playerBullets = [];
                    this.enemyBullets = [];
                    this.powerups = [];
                    this.particles = [];
                    this.boss = null;
                    this.updateUI();
                    document.getElementById('gameOverScreen').style.display = 'none';
                    document.getElementById('scoreboardScreen').style.display = 'none';
                }
            }
            restartGame() {
                this.gameStarted = true;
                this.resetGame();
            }
            showStartScreen() {
                document.getElementById('gameOverScreen').style.display = 'none';
                document.getElementById('scoreboardScreen').style.display = 'none';
                document.getElementById('startScreen').style.display = 'flex';
            }
            showScoreboard() {
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('scoreboardScreen').style.display = 'flex';
                this.loadHighScores();
            }
            hideScoreboard() {
                document.getElementById('scoreboardScreen').style.display = 'none';
                document.getElementById('startScreen').style.display = 'flex';
            }
            createEnemies() {
                if (this.level % 5 === 0) {
                    this.createBoss();
                    return;
                }
                this.enemies = [];
                const rows = Math.min(5, 3 + Math.floor(this.level / 2));
                const cols = Math.min(8, 6 + Math.floor(this.level / 3));
                const enemyWidth = 30;
                const enemyHeight = 25;
                const startX = 50;
                const startY = 135;
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const x = startX + col * (enemyWidth + 10);
                        const y = startY + row * (enemyHeight + 10);
                        this.enemies.push(new Enemy(x, y, row % 5));
                    }
                }
                this.enemyMoveDelay = Math.max(200, 1000 - (this.level - 1) * 80);
                this.enemyShootDelay = Math.max(500, 2000 - (this.level - 1) * 150);
            }
            createBoss() {
                this.enemies = [];
                this.boss = new Boss(this.canvas.width / 2 - 50, 50);
            }
            update() {
                if (!this.gameStarted || !this.gameRunning || this.gameOver) return;
                this.player.update(this.keys, this.canvas.width);
                if (this.keys.fire && this.player.canShoot()) {
                    this.firePlayerBullets();
                    this.player.resetShootTimer();
                    this.playSound('shoot');
                }
                this.playerBullets = this.playerBullets.filter(bullet => {
                    bullet.update();
                    return bullet.y > 0 && bullet.y < this.canvas.height;
                });
                this.enemyBullets = this.enemyBullets.filter(bullet => {
                    bullet.update();
                    return bullet.y < this.canvas.height && bullet.y > 0;
                });
                this.powerups = this.powerups.filter(powerup => {
                    powerup.update();
                    return powerup.active;
                });
                this.particles = this.particles.filter(particle => {
                    particle.update();
                    return particle.life > 0;
                });
                const currentTime = Date.now();
                if (currentTime - this.lastEnemyMoveTime > this.enemyMoveDelay) {
                    this.moveEnemies();
                    this.lastEnemyMoveTime = currentTime;
                }
                if (currentTime - this.lastEnemyShootTime > this.enemyShootDelay) {
                    this.enemyShoot();
                    this.lastEnemyShootTime = currentTime;
                }
                if (currentTime - this.lastPowerupSpawnTime > this.powerupSpawnDelay && Math.random() < 0.7) {
                    this.spawnPowerup();
                    this.lastPowerupSpawnTime = currentTime;
                }
                this.checkCollisions();
                if ((this.enemies.length === 0 && !this.boss) || (this.boss && this.boss.health <= 0)) {
                    this.nextLevel();
                }
                if (this.lives <= 0) {
                    this.endGame();
                }
            }
            firePlayerBullets() {
                if (this.player.powerup.spreadShot) {
                    this.playerBullets.push(new Bullet(this.player.x + this.player.width / 2 - 10, this.player.y, -7));
                    this.playerBullets.push(new Bullet(this.player.x + this.player.width / 2, this.player.y, -7));
                    this.playerBullets.push(new Bullet(this.player.x + this.player.width / 2 + 10, this.player.y, -7));
                } else if (this.player.powerup.rapidFire) {
                    this.playerBullets.push(new Bullet(this.player.x + this.player.width / 2, this.player.y, -9));
                    setTimeout(() => {
                        if (this.gameRunning) {
                            this.playerBullets.push(new Bullet(this.player.x + this.player.width / 2, this.player.y, -9));
                        }
                    }, 100);
                } else {
                    this.playerBullets.push(new Bullet(this.player.x + this.player.width / 2, this.player.y, -7));
                }
            }
            moveEnemies() {
                if (this.boss) {
                    this.boss.move(this.canvas.width);
                    return;
                }
                if (this.enemies.length === 0) return;
                let hitEdge = false;
                let direction = this.enemies[0].direction;
                for (let enemy of this.enemies) {
                    if ((enemy.x <= 0 && direction < 0) || (enemy.x >= this.canvas.width - enemy.width && direction > 0)) {
                        hitEdge = true;
                        break;
                    }
                }
                for (let enemy of this.enemies) {
                    if (hitEdge) {
                        enemy.y += 20;
                        enemy.direction *= -1;
                    } else {
                        enemy.x += enemy.direction * 10;
                    }
                    if (enemy.y + enemy.height >= this.canvas.height - 100) {
                        this.lives = 0;
                    }
                }
            }
            enemyShoot() {
                if (this.boss) {
                    this.boss.shoot(this.enemyBullets);
                    return;
                }
                if (this.enemies.length === 0) return;
                const bottomEnemies = {};
                this.enemies.forEach(enemy => {
                    if (!bottomEnemies[enemy.x]) bottomEnemies[enemy.x] = enemy;
                    else if (enemy.y > bottomEnemies[enemy.x].y) bottomEnemies[enemy.x] = enemy;
                });
                const shootingEnemies = Object.values(bottomEnemies);
                if (shootingEnemies.length > 0) {
                    const shootingEnemy = shootingEnemies[Math.floor(Math.random() * shootingEnemies.length)];
                    this.enemyBullets.push(new Bullet(shootingEnemy.x + shootingEnemy.width / 2, shootingEnemy.y + shootingEnemy.height, 4));
                }
            }
            spawnPowerup() {
                if (this.powerups.length >= 2) return;
                const types = ['spreadShot', 'shield', 'speedBoost', 'rapidFire'];
                const type = types[Math.floor(Math.random() * types.length)];
                const x = 50 + Math.random() * (this.canvas.width - 100);
                this.powerups.push(new Powerup(x, 0, type));
            }
            checkCollisions() {
                for (let i = this.playerBullets.length - 1; i >= 0; i--) {
                    const bullet = this.playerBullets[i];
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        if (this.collision(bullet, this.enemies[j])) {
                            this.createExplosion(bullet.x, bullet.y, 20, '#ff6600');
                            this.vibrate(50);
                            this.playerBullets.splice(i, 1);
                            this.enemies.splice(j, 1);
                            this.score += 10;
                            this.updateUI();
                            this.playSound('hit');
                            break;
                        }
                    }
                    if (this.boss && this.collision(bullet, this.boss)) {
                        this.createExplosion(bullet.x, bullet.y, 15, '#ff3300');
                        this.vibrate(100);
                        this.playerBullets.splice(i, 1);
                        this.boss.health -= 1;
                        this.playSound('hit');
                        if (this.boss.health <= 0) {
                            this.createExplosion(this.boss.x + this.boss.width/2, this.boss.y + this.boss.height/2, 50, '#ff0000');
                            this.vibrate(200);
                            this.score += 100;
                            this.updateUI();
                            this.playSound('explosion');
                        }
                        break;
                    }
                }
                for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
                    if (this.collision(this.enemyBullets[i], this.player)) {
                        if (this.player.powerup.shield) {
                            this.createExplosion(this.enemyBullets[i].x, this.enemyBullets[i].y, 10, '#00ffff');
                            this.vibrate(30);
                            this.playSound('hit');
                            this.enemyBullets.splice(i, 1);
                            this.player.powerup.shield = false;
                            this.updatePowerupUI();
                        } else {
                            this.createExplosion(this.enemyBullets[i].x, this.enemyBullets[i].y, 25, '#ff0000');
                            this.vibrate(150);
                            this.enemyBullets.splice(i, 1);
                            this.lives--;
                            this.updateUI();
                            this.playSound('explosion');
                            if (this.lives > 0) this.player.x = this.canvas.width / 2 -20;
                            break;
                        }
                    }
                }
                for (let enemy of this.enemies) {
                    if (this.collision(enemy, this.player)) {
                        this.lives = 0;
                        this.createExplosion(this.player.x + this.player.width/2, this.player.y + this.player.height/2, 40, '#ff0000');
                        this.vibrate(300);
                        this.playSound('explosion');
                        break;
                    }
                }
                if (this.boss && this.collision(this.boss, this.player)) {
                    this.lives = 0;
                    this.createExplosion(this.player.x + this.player.width/2, this.player.y + this.player.height/2, 60, '#ff0000');
                    this.vibrate(500);
                    this.playSound('explosion');
                }
                for (let i = this.powerups.length - 1; i >= 0; i--) {
                    if (this.collision(this.powerups[i], this.player)) {
                        this.collectPowerup(this.powerups[i]);
                        this.powerups.splice(i, 1);
                        this.createExplosion(this.player.x + this.player.width/2, this.player.y, 15, '#ffff00');
                        this.vibrate(80);
                        this.playSound('powerup');
                    }
                }
            }
            collectPowerup(powerup) {
                if (powerup.type === 'spreadShot' || powerup.type === 'rapidFire') {
                    this.player.powerup.spreadShot = false;
                    this.player.powerup.rapidFire = false;
                }
                this.player.powerup[powerup.type] = true;
                setTimeout(() => {
                    if (this.player) {
                        this.player.powerup[powerup.type] = false;
                        this.updatePowerupUI();
                    }
                }, 5000);
                this.updatePowerupUI();
            }
            createExplosion(x, y, count, color) {
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(
                        x,
                        y,
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 8,
                        Math.random() * 5 + 2,
                        color
                    ));
                }
            }
            vibrate(duration) {
                if (this.vibrationSupported) navigator.vibrate(duration);
            }
            collision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
            nextLevel() {
                this.level++;
                this.createEnemies();
                this.updateUI();
            }
            endGame() {
                this.gameOver = true;
                this.gameRunning = false;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('continueLevel').textContent = this.level;
                document.getElementById('gameOverScreen').style.display = 'flex';
                document.getElementById('nicknameForm').style.display = 'block';
                document.getElementById('scoreSubmittedMessage').style.display = 'none';
                document.getElementById('submitNickname').disabled = false;
                this.generatePayPalSessionToken();
            }
            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('level').textContent = this.level;
            }
            updatePowerupUI() {
                let status = "None";
                const p = this.player.powerup;
                if (p.shield) status = "🛡️ Shield";
                if (p.speedBoost) status = "⚡ Speed Boost";
                if (p.spreadShot) status = "🎯 Spread Shot";
                if (p.rapidFire) status = "💨 Rapid Fire";
                if (p.shield && p.speedBoost) status = "🛡️⚡ Shield + Speed";
                if (p.shield && p.spreadShot) status = "🛡️🎯 Shield + Spread";
                if (p.shield && p.rapidFire) status = "🛡️💨 Shield + Rapid";
                if (p.speedBoost && p.spreadShot) status = "⚡🎯 Speed + Spread";
                if (p.speedBoost && p.rapidFire) status = "⚡💨 Speed + Rapid";
                document.getElementById('powerupStatus').textContent = status;
            }
            playSound(type) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    switch(type) {
                        case 'shoot':
                            oscillator.type = 'square';
                            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                            oscillator.start(audioContext.currentTime);
                            oscillator.stop(audioContext.currentTime + 0.1);
                            break;
                        case 'hit':
                            oscillator.type = 'sine';
                            oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                            oscillator.start(audioContext.currentTime);
                            oscillator.stop(audioContext.currentTime + 0.2);
                            break;
                        case 'explosion':
                            oscillator.type = 'sawtooth';
                            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                            oscillator.start(audioContext.currentTime);
                            oscillator.stop(audioContext.currentTime + 0.5);
                            break;
                        case 'powerup':
                            oscillator.type = 'triangle';
                            oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                            oscillator.start(audioContext.currentTime);
                            oscillator.stop(audioContext.currentTime + 0.3);
                            break;
                    }
                } catch(e) {}
            }
            render() {
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#000428');
                gradient.addColorStop(0.5, '#004e92');
                gradient.addColorStop(1, '#000428');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                const time = Date.now() * 0.001;
                for (let star of this.stars) {
                    const twinkle = Math.sin(time * star.twinkleSpeed + star.twinklePhase) * 0.3 + 0.7;
                    const alpha = star.brightness * twinkle;
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillStyle = star.color || '#ffffff';
                    if (star.size > 2) {
                        this.ctx.shadowColor = star.color || '#ffffff';
                        this.ctx.shadowBlur = star.size * 2;
                    }
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                this.ctx.globalAlpha = 1;
                if (!this.gameStarted) return;
                for (let particle of this.particles) particle.draw(this.ctx);
                for (let powerup of this.powerups) powerup.draw(this.ctx);
                if (this.player) this.player.draw(this.ctx);
                if (this.boss) this.boss.draw(this.ctx);
                else for (let enemy of this.enemies) enemy.draw(this.ctx);
                for (let bullet of this.playerBullets) bullet.draw(this.ctx, '#00ffff');
                for (let bullet of this.enemyBullets) bullet.draw(this.ctx, '#ff4444');
            }
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
            async generatePayPalSessionToken() {
                try {
                    const response = await fetch('/api/create-session', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ level: this.level })
                    });
                    if (response.ok) {
                        const data = await response.json();
                        document.getElementById('paypalSessionToken').value = data.sessionToken;
                        this.paypalSessionToken = data.sessionToken;
                    } else {
                        console.error('Failed to create PayPal session');
                    }
                } catch (error) {
                    console.error('Error creating PayPal session:', error);
                }
            }
            async loadHighScores() {
                const loadingMessage = document.getElementById('loadingMessage');
                const scoreboardBody = document.getElementById('scoreboardBody');
                try {
                    loadingMessage.style.display = 'block';
                    scoreboardBody.innerHTML = '';
                    const response = await fetch('/api/scores', {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    if (response.ok) {
                        const data = await response.json();
                        this.displayHighScores(data.items);
                        loadingMessage.style.display = 'none';
                    } else {
                        console.error('Failed to load high scores:', response.statusText);
                        loadingMessage.textContent = 'Failed to load scores';
                    }
                } catch (error) {
                    console.error('Error loading high scores:', error);
                    loadingMessage.textContent = 'Error loading scores';
                }
            }
            displayHighScores(scores) {
                const tbody = document.getElementById('scoreboardBody');
                tbody.innerHTML = '';
                if (scores.length === 0) {
                    const row = document.createElement('tr');
                    row.innerHTML = `<td colspan="4">No scores yet!</td>`;
                    tbody.appendChild(row);
                    return;
                }
                const topScores = scores.slice(0, 10);
                topScores.forEach((score, index) => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td>${score.player_name || 'Unknown'}</td>
                        <td>${score.score}</td>
                        <td>${score.level || '1'}</td>
                    `;
                    tbody.appendChild(row);
                });
            }
            async saveHighScore(nickname) {
                try {
                    const data = { score: this.score, player_name: nickname, level: this.level };
                    const response = await fetch('/api/scores', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    if (response.ok) {
                        console.log('Score saved successfully');
                        document.getElementById('nicknameForm').style.display = 'none';
                        document.getElementById('scoreSubmittedMessage').style.display = 'block';
                    } else {
                        console.error('Failed to save score:', response.statusText);
                        alert('Failed to save your score. Please try again.');
                        document.getElementById('submitNickname').disabled = false;
                    }
                } catch (error) {
                    console.error('Error saving score:', error);
                    alert('Failed to save your score. Please try again.');
                    document.getElementById('submitNickname').disabled = false;
                }
            }
        }
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 30;
                this.speed = 6;
                this.lastShot = 0;
                this.shootDelay = 200;
                this.thrusterPhase = 0;
                this.powerup = { shield: false, speedBoost: false, spreadShot: false, rapidFire: false };
            }
            update(keys, canvasWidth) {
                const moveSpeed = this.powerup.speedBoost ? this.speed * 1.5 : this.speed;
                if (keys.left && this.x > 0) this.x -= moveSpeed;
                if (keys.right && this.x < canvasWidth - this.width) this.x += moveSpeed;
                if (this.powerup.rapidFire) this.shootDelay = 100;
                else this.shootDelay = 200;
                this.thrusterPhase += 0.3;
            }
            canShoot() { return Date.now() - this.lastShot > this.shootDelay; }
            resetShootTimer() { this.lastShot = Date.now(); }
            draw(ctx) {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                if (this.powerup.shield) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, this.width * 0.8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, this.width * 0.8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
                gradient.addColorStop(0, '#00ffff');
                gradient.addColorStop(0.5, '#0088ff');
                gradient.addColorStop(1, '#0044aa');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(centerX, this.y);
                ctx.lineTo(this.x + this.width * 0.8, this.y + this.height * 0.6);
                ctx.lineTo(this.x + this.width * 0.9, this.y + this.height);
                ctx.lineTo(this.x + this.width * 0.1, this.y + this.height);
                ctx.lineTo(this.x + this.width * 0.2, this.y + this.height * 0.6);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.moveTo(centerX, this.y + 2);
                ctx.lineTo(this.x + this.width * 0.7, this.y + this.height * 0.5);
                ctx.lineTo(this.x + this.width * 0.3, this.y + this.height * 0.5);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#44aaff';
                ctx.fillRect(this.x + 2, this.y + this.height * 0.7, 8, 6);
                ctx.fillRect(this.x + this.width - 10, this.y + this.height * 0.7, 8, 6);
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.arc(centerX, this.y + this.height * 0.4, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                const thrusterIntensity = Math.sin(this.thrusterPhase) * 0.3 + 0.7;
                ctx.fillStyle = `rgba(255, ${Math.floor(100 + thrusterIntensity * 155)}, 0, ${thrusterIntensity})`;
                ctx.beginPath();
                ctx.ellipse(this.x + this.width * 0.2, this.y + this.height + 5, 3, 8 * thrusterIntensity, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(this.x + this.width * 0.8, this.y + this.height + 5, 3, 8 * thrusterIntensity, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.ellipse(this.x + this.width * 0.2, this.y + this.height + 2, 2, 4 * thrusterIntensity, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(this.x + this.width * 0.8, this.y + this.height + 2, 2, 4 * thrusterIntensity, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 25;
                this.type = type;
                this.direction = 1;
                this.animationPhase = Math.random() * Math.PI * 2;
            }
            draw(ctx) {
                this.animationPhase += 0.1;
                const pulse = Math.sin(this.animationPhase) * 0.2 + 0.8;
                const colors = [
                    { primary: '#ff3366', secondary: '#ff6699', glow: '#ff0044' },
                    { primary: '#ff6600', secondary: '#ffaa44', glow: '#ff4400' },
                    { primary: '#ffff00', secondary: '#ffff88', glow: '#ffdd00' },
                    { primary: '#aa00ff', secondary: '#cc66ff', glow: '#8800dd' },
                    { primary: '#00ff88', secondary: '#66ffaa', glow: '#00dd66' }
                ];
                const color = colors[this.type] || colors[0];
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                ctx.shadowColor = color.glow;
                ctx.shadowBlur = 8 * pulse;
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, this.width / 2);
                gradient.addColorStop(0, color.secondary);
                gradient.addColorStop(1, color.primary);
                ctx.fillStyle = gradient;
                switch(this.type) {
                    case 0:
                        ctx.beginPath();
                        ctx.moveTo(centerX, this.y + 3);
                        ctx.lineTo(this.x + this.width - 3, this.y + this.height - 3);
                        ctx.lineTo(this.x + 3, this.y + this.height - 3);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 1:
                        ctx.beginPath();
                        const sides = 8;
                        const radius = this.width / 2.5;
                        for (let i = 0; i < sides; i++) {
                            const angle = (i * 2 * Math.PI) / sides;
                            const x = centerX + radius * Math.cos(angle);
                            const y = centerY + radius * Math.sin(angle);
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 2:
                        ctx.beginPath();
                        ctx.moveTo(centerX, this.y + 2);
                        ctx.lineTo(this.x + this.width - 2, centerY);
                        ctx.lineTo(centerX, this.y + this.height - 2);
                        ctx.lineTo(this.x + 2, centerY);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    default:
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, this.width / 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = pulse;
                if (this.type <= 2) {
                    ctx.beginPath();
                    ctx.arc(centerX - 6, centerY - 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(centerX + 6, centerY - 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.strokeStyle = color.primary;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.moveTo(centerX - 8, this.y);
                ctx.lineTo(centerX - 12, this.y - 5);
                ctx.moveTo(centerX + 8, this.y);
                ctx.lineTo(centerX + 12, this.y - 5);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
        }
        class Boss {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 100;
                this.height = 80;
                this.health = 20;
                this.maxHealth = 20;
                this.direction = 1;
                this.moveSpeed = 2;
                this.lastDirectionChange = Date.now();
                this.animationPhase = 0;
                this.gunPositions = [
                    { x: 0.2, y: 0.8 },
                    { x: 0.5, y: 0.9 },
                    { x: 0.8, y: 0.8 }
                ];
            }
            move(canvasWidth) {
                if (Date.now() - this.lastDirectionChange > 2000) {
                    this.direction = Math.random() > 0.5 ? 1 : -1;
                    this.lastDirectionChange = Date.now();
                }
                this.x += this.direction * this.moveSpeed;
                if (this.x <= 0) {
                    this.x = 0;
                    this.direction = 1;
                } else if (this.x >= canvasWidth - this.width) {
                    this.x = canvasWidth - this.width;
                    this.direction = -1;
                }
                this.animationPhase += 0.05;
            }
            shoot(enemyBullets) {
                this.gunPositions.forEach(pos => {
                    const x = this.x + this.width * pos.x;
                    const y = this.y + this.height * pos.y;
                    if (Math.random() < 0.3) {
                        enemyBullets.push(new Bullet(x, y, 3));
                        enemyBullets.push(new Bullet(x - 10, y, 3));
                        enemyBullets.push(new Bullet(x + 10, y, 3));
                    } else {
                        enemyBullets.push(new Bullet(x, y, 3));
                    }
                });
            }
            draw(ctx) {
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                const bodyGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, this.width / 2);
                bodyGradient.addColorStop(0, '#ff0000');
                bodyGradient.addColorStop(0.7, '#aa0000');
                bodyGradient.addColorStop(1, '#660000');
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y);
                ctx.lineTo(this.x + this.width, this.y + this.height * 0.3);
                ctx.lineTo(this.x + this.width * 0.8, this.y + this.height);
                ctx.lineTo(this.x + this.width * 0.2, this.y + this.height);
                ctx.lineTo(this.x, this.y + this.height * 0.3);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(this.x + this.width * 0.3, this.y + this.height * 0.4, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.x + this.width * 0.7, this.y + this.height * 0.4, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                const eyeOffset = Math.sin(this.animationPhase) * 3;
                ctx.beginPath();
                ctx.arc(this.x + this.width * 0.3 + eyeOffset, this.y + this.height * 0.4, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.x + this.width * 0.7 + eyeOffset, this.y + this.height * 0.4, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#333';
                this.gunPositions.forEach(pos => {
                    const gunX = this.x + this.width * pos.x;
                    const gunY = this.y + this.height * pos.y;
                    ctx.fillRect(gunX - 5, gunY - 5, 10, 15);
                });
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y);
                ctx.lineTo(this.x + this.width, this.y + this.height * 0.3);
                ctx.lineTo(this.x + this.width * 0.8, this.y + this.height);
                ctx.lineTo(this.x + this.width * 0.2, this.y + this.height);
                ctx.lineTo(this.x, this.y + this.height * 0.3);
                ctx.closePath();
                ctx.stroke();
                ctx.shadowBlur = 0;
                const healthWidth = (this.health / this.maxHealth) * this.width;
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x, this.y - 15, this.width, 8);
                ctx.fillStyle = this.health > this.maxHealth * 0.6 ? '#00ff00' :
                               this.health > this.maxHealth * 0.3 ? '#ffff00' : '#ff0000';
                ctx.fillRect(this.x, this.y - 15, healthWidth, 8);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - 15, this.width, 8);
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`BOSS ${this.health}/${this.maxHealth}`, centerX, this.y - 5);
            }
        }
        class Bullet {
            constructor(x, y, speed) {
                this.x = x;
                this.y = y;
                this.width = 4;
                this.height = 12;
                this.speed = speed;
                this.trail = [];
                this.maxTrailLength = 8;
            }
            update() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) this.trail.shift();
                this.y += this.speed;
            }
            draw(ctx, color) {
                for (let i = 0; i < this.trail.length; i++) {
                    const alpha = (i + 1) / this.trail.length * 0.5;
                    const size = (i + 1) / this.trail.length;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(this.trail[i].x, this.trail[i].y, this.width * size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                ctx.shadowColor = color;
                ctx.shadowBlur = 8;
                const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
                if (this.speed < 0) {
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.5, color);
                    gradient.addColorStop(1, '#ffffff');
                } else {
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.5, color);
                    gradient.addColorStop(1, '#aa0000');
                }
                ctx.fillStyle = gradient;
                if (this.speed < 0) {
                    ctx.beginPath();
                    ctx.ellipse(this.x, this.y + this.height/2, this.width/2, this.height/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x - this.width/2, this.y + this.height);
                    ctx.lineTo(this.x + this.width/2, this.y + this.height);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
        }
        class Powerup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.type = type;
                this.speed = 2;
                this.active = true;
                this.floatPhase = Math.random() * Math.PI * 2;
                this.colors = {
                    spreadShot: '#ff00ff',
                    shield: '#00ffff',
                    speedBoost: '#ffff00',
                    rapidFire: '#ff8800'
                };
                this.symbols = {
                    spreadShot: '🎯',
                    shield: '🛡️',
                    speedBoost: '⚡',
                    rapidFire: '💨'
                };
            }
            update() {
                this.y += this.speed;
                this.floatPhase += 0.1;
                if (this.y > 700) this.active = false;
            }
            draw(ctx) {
                const floatOffset = Math.sin(this.floatPhase) * 5;
                const x = this.x;
                const y = this.y + floatOffset;
                ctx.shadowColor = this.colors[this.type];
                ctx.shadowBlur = 15;
                const gradient = ctx.createRadialGradient(x + this.width/2, y + this.height/2, 0, x + this.width/2, y + this.height/2, this.width/2);
                gradient.addColorStop(0, this.colors[this.type]);
                gradient.addColorStop(1, '#333');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x + this.width/2, y + this.height/2, this.width/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#fff';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.symbols[this.type], x + this.width/2, y + this.height/2);
                ctx.strokeStyle = this.colors[this.type];
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x + this.width/2, y + this.height/2, this.width/2 - 1, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        class Particle {
            constructor(x, y, vx, vy, size, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.size = size;
                this.color = color;
                this.life = 1.0;
                this.decay = 0.02 + Math.random() * 0.02;
                this.gravity = 0.1;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life -= this.decay;
                this.size *= 0.97;
            }
            draw(ctx) {
                if (this.life <= 0) return;
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = this.size;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }
        window.addEventListener('load', () => {
            new SpaceInvadersGame();
        });
    </script>
</body>
</html>
